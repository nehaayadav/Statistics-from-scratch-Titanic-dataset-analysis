# -*- coding: utf-8 -*-
"""Statistics from Scratch: Titanic Dataset Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10UKb4GA3S1jBujo1lR-8Val7aKPTAAiA

# Descriptive Statistics

### Importing important libraries
"""

import matplotlib.pyplot as plt
import numpy as np
import math
import pandas as pd
from google.colab import drive

drive.mount('/content/drive')

titanic = pd.read_csv("/content/drive/MyDrive/Dataset/titanic dataset/Titanic-Dataset.csv")

titanic.head()

titanic.shape

titanic = titanic.drop(columns = 'PassengerId')

titanic.isnull().sum()

titanic.info()

titanic.describe()

print(titanic.dtypes)

titanic = titanic.dropna(subset=['Age'])

"""### 1.1 Mean"""

column = titanic.select_dtypes(include=["int64", "float64"]).columns

column

def calc_mean(inputs):
  n = len(inputs)
  sum = 0
  for i in inputs:
    sum += i
  return sum/n

for c in column:
  print(c, 'mean:', calc_mean(titanic[c]))

"""### 1.2 Median"""

def calc_median(inputs):
  arr = sorted(inputs)
  n = len(arr)
  if n % 2 == 1:
    median = arr[(n//2)]
  else:
    median = (arr[n // 2 - 1] + arr[n // 2])/2
  return median

for c in column:
  print(c, 'median:', calc_median(titanic[c]))

"""### 1.3 Mode"""

def calc_mode(inputs):
  freq = {}   # dictionary for frequency count
  for val in inputs:
    if val in freq:
      freq[val] += 1
    else:
      freq[val] = 1
  # find max frequency
  max_count = max(freq.values())
  # all values that have max frequency (multimodal case handle)
  modes = [k for k, v in freq.items() if v == max_count]
  return modes      # multiple modes

for c in column:
  print(c, 'mode:', calc_mode(titanic[c]))

"""### 1.4 min-max, Range"""

def min_max(inputs):
  arr = sorted(inputs)
  n = len(arr)
  min = arr[0]
  max = arr[n-1]
  range = max - min
  return {'min': min, 'max': max, 'range': range}

for c in column:
  print(c, min_max(titanic[c]))
  print('-'*10)

"""### 1.5 Variance"""

def calc_variance(inputs):
  mean = calc_mean(inputs)
  sum_squared_diff = 0
  n = len(inputs)
  for i in inputs:
    sum_squared_diff += (i - mean)**2
  return (sum_squared_diff/n)

for c in column:
  print(c, 'variance:', calc_variance(titanic[c]))

"""### 1.6 Standard Deviation"""

def calc_std_dev(inputs):
  variance = calc_variance(inputs)
  return math.sqrt(variance)

for c in column:
  print(c, 'Standard Deviation:', calc_std_dev(titanic[c]))

"""### 1.7  Quartiles, Percentiles"""

def quartiles(inputs):
  arr = sorted(inputs)
  n = len(arr)
  Q2 = calc_median(arr)
  lower_half = arr[:n//2]
  upper_half = arr[n//2:]
  Q1 = calc_median(lower_half)
  Q3 = calc_median(upper_half)
  IQR = Q3 - Q1
  return {'Q1': Q1, 'Q2': Q2, 'Q3': Q3}

for c in column:
  print(c, quartiles(titanic[c]))
  print('-'*10)

"""# 2. Relationships

### 2.1 Covariance

Covariance is calculated between 2 features to measure how two variable change together.

Here lets take fare vs survival. To see if rich people have survived more.
"""

def calc_covariance(x, y):
  n = len(x)
  sum = 0
  for i in range(n):
    sum += (x.iloc[i] - calc_mean(x)) * (y.iloc[i] - calc_mean(y))
  return sum/n

covariance = calc_covariance(titanic['Fare'], titanic['Survived'])
print('The covariance score between fare and survived is', covariance)

"""### 2.2 Pearson correlation

Pearson correlation measures a linear relationship between two variables
"""

def PCC(x, y):
  n = len(x)
  x_mean = calc_mean(x)
  y_mean = calc_mean(y)
  sum = 0
  sum_x = 0
  sum_y = 0
  for i in range(n):
    sum += ((x.iloc[i] - x_mean) * (y.iloc[i] - y_mean))
    sum_x += (x.iloc[i] - x_mean)**2
    sum_y += (y.iloc[i] - y_mean)**2
  return (sum) / math.sqrt(sum_x * sum_y)

pcc = PCC(titanic['Fare'], titanic['Survived'])
print('PCC score between fare and survived is', pcc)

"""### 2.3 Spearman rank correlation coefficient"""

titanic['Fare_rank'] = titanic['Fare'].rank()
titanic['age_rank'] = titanic['Age'].rank()
srcc = PCC(titanic['Fare_rank'], titanic['age_rank'])

print('SRCC score between fare and age is', srcc)

"""# 3. Probability and Distributions

### 3.1 Bernoulli Distribution
"""

def ber_pmf(x):
  count = sum(1 for i in x if i==1)
  p = count/len(x)
  q = 1 - p
  return  p, q

ber_pmf = ber_pmf(titanic['Survived'])
ber_values = [1, 0]

plt.bar(ber_values, ber_pmf, width= 0.7, color = ['red', 'blue']) # Creates a line plot
#or for a scatter plot:
# plt.plot(x_data, y_data, 'o') # 'o' specifies marker style (circles)
plt.xlabel("values")
plt.ylabel("PMF")
plt.title("Bernoulli Distribution")
plt.show()

#bernoulli mean
def ber_mean(x):
  count = sum(1 for i in x if i==1)
  p = count/(len(x))
  return p

ber_mean = ber_mean(titanic['Survived'])
print('Bernoulli Distrbution mean:', ber_mean)

# Bernoulli variance
def ber_var(inputs):
  p = ber_mean
  q = 1 - p
  return p*q

print('Bernoulli Distribution variance:', ber_var(titanic['Survived']))

"""## 3.2 Binomial Distribution"""

def bin_pmf(inputs):
  n = len(inputs)
  prob_list = []
  p = sum(inputs)/n
  q = 1 - p
  for k in range(n):
    nCk = math.factorial(n) / (math.factorial(k) * (math.factorial(n-k)))
    f = nCk * (p ** k) * (q ** (n-k))
    prob_list.append(f)
  return prob_list

y_bin = bin_pmf(titanic['Survived'])
x_bin = list(range(len(y_bin))) #taking k on x_axis

plt.plot(x_bin, y_bin, marker='o')
plt.title("Binomial ditribution PMF (from scratch)")
plt.xlabel("x")
plt.ylabel("Probability Density")
plt.grid(True)
plt.show()

# binomial mean
def bin_mean(inputs):
  n = len(inputs)
  k = sum(inputs)
  p = k/n
  return n * p
print('Binomial Distribution mean:', bin_mean(titanic['Survived']))

# Binomial Variance
def bin_var(inputs):
  n = len(inputs)
  k = sum(inputs)
  p = k/n
  q = 1 - p
  return n*p*q
print('Binomial Distribution variance:', bin_var(titanic['Survived']))

"""## 3.3 Uniform Distribution"""

def uni_pmf_discrete(inputs):
    unique_vals = sorted(set(inputs))
    n_unique = len(unique_vals)
    pmf_dict = {}
    for val in unique_vals:
        pmf_dict[val] = 1 / n_unique
    return pmf_dict

pmf_pclass = uni_pmf_discrete(titanic['Pclass'])

# Plot PMF
plt.figure(figsize=(4,3))
plt.bar(pmf_pclass.keys(), pmf_pclass.values(), color='skyblue', edgecolor='black')
plt.xlabel("Pclass")
plt.ylabel("Probability")
plt.title("Discrete Uniform PMF of Pclass")
plt.show()

pmf_dict = uni_pmf_discrete(titanic['Pclass'])
uni_mean = sum(k * v for k, v in pmf_dict.items())
uni_variance = sum(v * (k - uni_mean)**2 for k, v in pmf_dict.items())

print("Discrete Uniform (Pclass) mean:", uni_mean)
print("Discrete Uniform (Pclass) variance:", uni_variance)

"""## 3.3 Normal/Gaussian Distribution"""

# Gaussian PDF

def gaus_pdf(inputs):
  variance = calc_variance(inputs)
  mean = calc_mean(inputs)
  pdf_values= []

  for i in inputs:
    exponent = ((i - mean) ** 2 ) / (2 * variance)
    base = 1/ (math.sqrt(2 * math.pi * variance))
    f = base * math.exp(- exponent)
    pdf_values.append(f)
  return pdf_values

#x_gaus =  titanic['Age']
x_gaus =  sorted(titanic['Age'])
y_gaus = gaus_pdf(x_gaus)

plt.plot(x_gaus, y_gaus, marker='o')
plt.title("Gaussian PDF (from scratch)")
plt.xlabel("x")
plt.ylabel("Probability Density")
plt.grid(True)
plt.show()

#Gaussian Mean
gaus_mean =  calc_mean(titanic['Age'])
print('Gaussian Distribution mean:', gaus_mean)

#Gaussian Variance
def calc_variance(values):
  mean = calc_mean(values)
  total = 0
  for x in values:
    total += (x - mean) ** 2
  return total / len(values)   # population variance (divide by n)
print('Gaussian Distribution variance:', calc_variance(titanic['Age']))

"""## 3.4 Log-Normal Distribution"""

# we will use Fare feature here
# As it is always positive, right skewed

def log_nor_pdf(inputs):
  std_dev = calc_std_dev(inputs)
  mean = calc_mean(inputs)
  variance = calc_variance(inputs)
  pdf_values = []
  for i in inputs:
    if i <= 0:
      pdf_values.append(0)  # log-normal undefined for x <= 0
    else:
      base = 1 / (i* std_dev * math.sqrt(2 * math.pi))
      exponent = - (((math.log(i) - mean)**2) / (2 * variance))
      f = base * math.exp(exponent)
      pdf_values.append(f)
  return pdf_values

#x_gaus =  titanic['Age']
x_log =  sorted(titanic['Age'])
y_log = log_nor_pdf(x_gaus)

plt.plot(x_log, y_log, marker='o')
plt.title("Log-Normal PDF (from scratch)")
plt.xlabel("x")
plt.ylabel("Probability Density")
plt.grid(True)
plt.show()

#Log-Normal Mean
def log_nor_mean(inputs):
  log_values = [math.log(x) for x in inputs if x > 0]
  exponent = calc_mean(log_values) + (calc_variance(log_values)/2)
  return math.exp(exponent)
  #return math.exp(calc_mean(inputs) + (calc_variance(inputs)/2))

print('Log Normal Distribution mean:', log_nor_mean(titanic['Fare']))

#log-Normal variance

def log_nor_var(inputs):
  log_values = [math.log(x) for x in inputs if x > 0]
  variance = calc_variance(log_values)
  mean = calc_mean(log_values)
  base = math.exp(variance) - 1
  exponent = math.exp((2* mean) + variance)
  return base * exponent

print('Log Normal Distribution variance:', log_nor_var(titanic['Fare']))